<!doctype html>
<html class="no-js" lang="">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <title>pwndevils</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="manifest" href="site.webmanifest">
    <link rel="apple-touch-icon" href="../icon.png">
    <!-- Place favicon.ico in the root directory -->
    <link rel="stylesheet" href="../css/normalize.css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" href="../css/main.css">
    <link rel="stylesheet" href="../highlight/styles/default.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
</head>

<body data-spy="scroll" data-target="#scroll-navbar" data-offset="100">
    <!--[if lte IE 9]>
            <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
        <![endif]-->
    <!-- Add your site or application content here -->
    <nav id="scroll-navbar" class="navbar navbar-inverse navbar-fixed-top">
        <div class="container-fluid">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#nav-content">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="../index.html">PWNDEVILS</a>
            </div>
            <div class="collapse navbar-collapse" id="nav-content">
                <ul class="nav navbar-nav">
                    <li class="dropdown">
                        <a class="dropdown-toggle" data-toggle="dropdown" href="../index.html">Home
                        <span class="caret"></span></a>
                        <ul class="dropdown-menu">
                            <li><a href="../index.html#about-club">About Club</a></li>
                            <li><a href="../index.html#about-faculty">Faculty</a></li>
                            <li><a href="../index.html#calendar">Calendar</a></li>
                            <li><a href="../index.html#videos">Videos</a></li>
                            <li><a href="../index.html#getting-started">Getting Started</a></li>
                            <li><a href="../index.html#history">History</a></li>
                        </ul>
                        <li><a href="#binary-exploit">Binary Exploitation</a></li>
                    </li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li class="active"><a href="#banner">How2Hack</a></li>
                </ul>
            </div>
        </div>
    </nav>
    <div id="loader-wrapper">
        <div id="loader"></div>
        <div class="loader-section section-left"></div>
        <div class="loader-section section-right"></div>
    </div>
    <div id="banner" class="container-fluid top-pad" style="background: black;">
        <div class="row">
            <img src="../img/pwndevils_banner.jpg" id="banner-img" alt="pwndevils ctf" class="img-responsive" />
        </div>
    </div>
    <div class="jumbotron text-center">
        <p>You have reached the amazingly awesome page of the <a href="https://ctftime.org/team/14321">pwndevils</a>, a hacking group started at Arizona State University. We love learning about computer systems and competing in <a href="https://en.wikipedia.org/wiki/Capture_the_flag#Computer_security">Capture the Flag</a> to demonstrate our computer security knowledge.</p>
    </div>
    <div id="hacking-info" class="container bottom-pad">
        <div class="row">
            <h1 class="text-center"><b>So You Want To Learn How To Hack?</b></h1>
            <h4 class="text-center bottom-pad">Pick a category that interests you and get started!</h4>
            <div class="col-sm-4">
                <div class="col-sm-12 well">
                    <h2 class="text-center">Binary Exploitation</h2>
                    <p class="left-margin">Software applications that can be effected either locally or remotely by outside users.
                        <br>Sections:</br>
                        <ul>
                            <li>Tools</li>
                            <li>x86 Assembly</li>
                            <li>Buffer Overflows</li>
                            <li>Shellcode</li>
                            <li>Format Strings</li>
                            <li>ROP: Return Oriented Programming</li>
                            <li>Heap Exploitation</li>
                        </ul>
                        <br>
                    </p>
                    <button type="button" class="btn btn-success btn-lg center-block" onclick="location.href='#binary-exploit'">Exploit Some Binaries!</button>
                </div>
            </div>
            <div class="col-sm-4">
                <div class="col-sm-12 well">
                    <h2 class="text-center">Web Exploitation</h2>
                    <p class="left-margin">Web applications that can be effected to either gain undue permissions or access to sensitive information.
                        <br>Sections:</br>
                        <ul>
                            <li>Tools</li>
                            <li>Exploiting The Basics</li>
                            <li>XSS: Cross-side Scripting</li>
                            <li>XSRF: Cross-side Request Forgery</li>
                            <li>Configuration Vulnerabilities</li>
                        </ul>
                        <br></br>
                    </p>
                    <button type="button" class="btn btn-primary btn-lg center-block disabled">Wreck Some Sites!</button>
                </div>
            </div>
            <div class="col-sm-4">
                <div class="col-sm-12 well">
                    <h2 class="text-center">Cryptography</h2>
                    <p class="left-margin">Some application of cryptographic function(s) to turn plaintext into ciphertext.
                        <br>Sections:</br>
                        <ul>
                            <li>Resources</li>
                            <li>Basic Ciphers</li>
                            <li>ECB &amp; CBC</li>
                            <li>AES &amp; Public/Private Crypto</li>
                            <li>What To Look For</li>
                            <li>How To Approach It</li>
                        </ul>
                        <br></br>
                    </p>
                    <button type="button" class="btn btn-danger btn-lg center-block disabled">Break Some Codes!</button>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="col-sm-4">
                <div class="col-sm-12 well">
                    <h2 class="text-center">Forensics</h2>
                    <p class="left-margin">Disk or Network Traffic captures that have some form of interesting conversation or data.
                        <br>Sections:</br>
                        <ul>
                            <li>Tools</li>
                            <li>Physical Storage</li>
                            <li>Network Traffic</li>
                            <li>Partial Data Recovery</li>
                            <li>Time Stamp Manipulation</li>
                        </ul>
                        <br></br>
                    </p>
                    <button type="button" class="btn btn-warning btn-lg center-block disabled">Find Something Hidden!</button>
                </div>
            </div>
        </div>
    </div>
    <div id="binary-exploit" class="container-fluid bottom-pad">
        <h1 class="text-center bottom-pad parallax" style="padding-top: 40px;"><b>Binary Exploitation</b></h1>
        <div class="row center-block" id="binary-tools">
            <h2 class="text-center"><b>Tools</b></h2>
            <div class="col-sm-3 col-sm-offset-1">
                <div class="col-sm-11 col-sm-offset-2">
                    <p>The first thing that you want to do is set up your environment. If you're not running some version of linux you can use a Virtual Machine (You can use a MAC, but a VM is recommended). A good free option is <a href="https://www.virtualbox.org/wiki/Downloads">Oracle's VirtualBox</a>, but you can use any Virtul Machine softare you're comfortable with.</p>
                </div>
            </div>
            <div class="col-sm-3">
                <div class="col-sm-11 col-sm-offset-2">
                    <p>Once you have a VM software, you'll need a linux operating system. If you're new to linux, I'd suggest going with <a href="https://www.ubuntu.com/desktop/1710">Ubuntu</a>, but you can use any linux operating system that you want to. If you're on a 64-bit linux system, we'll want to install the necessary 32-bit libraries. Install them on Ubuntu using <b>sudo apt-get install gcc-multilib</b>.</p>
                </div>
            </div>
            <div class="col-sm-4">
                <div class="col-sm-9 col-sm-offset-1">
                    <p>Let's set up our python environment! We'll be using python2.7 for some of our challenges so everything that we install will be for that version. A fantastic library of explotation tools for python is <a href="https://docs.pwntools.com/en/stable/">pwntools</a>. You can install it with <b>pip install pwntools</b>. We'll also install <a href="https://github.com/JonathanSalwan/ROPgadget">ROPgadget</a> with <b>pip install ropgadget</b>. There are some dependencies for this library which may cause problems. An optional upgrade for GDB called <a href="https://github.com/hugsy/gef">GEF</a>.</p>
                </div>
            </div>
        </div>
        <div class="row bottom-pad" id="assembly">
            <h2 class="text-center bottom-pad"><b>x86 Assembly</b></h2>
            <h3 class="text-center">Global Variables</h3>
            <div class="col-sm-3 col-sm-offset-3">
                <pre><code class="language-cpp">   
    int a;
    int b;
    float c;
    int main() {
        a = 10;
        b = 100;
        c = 10.45;
        a = a + b;
        return 0;
    }
                </code></pre>
            </div>
            <div class="col-sm-3">
                <pre><code class="x86asm hljs">    ;a @ 0x8049634
    ;b @ 0x8049638
    ;c @ 0x804963c
    main:
        movl 0x8049634, 0xa
        movl 0x8049638, 0x64
        mov eax, 0x41273333
        mov 0x804963c, eax
        mov edx, 0x8049634
        mov eax, 0x8049638
        lea eax, [edx+eax*1]
        mov 0x8049634, eax</code></pre>
            </div>
        </div>
        <div class="row bottom-pad">
            <div class="col-sm-6 col-sm-offset-3">
                <div class="row">
                    <div class="col-sm-8">
                        <p>So what's going on here? Above are two snippets of code, the first is C code for a small program and the second is it's corresponding x86 assembly code. Let's take a look first at what our variables are in the C code and how they relate to the assembly code.</p>
                        <p>The first three lines of C code declare some global variables, two int's and one float. However, the equivalent lines for x86 show that the variables are actualy stored at memory locations. Notice that each of the locations are offests of 4 from eachother. This is due to the fact that int's and floats take up 32-bits or 4 bytes each. The second thing to notice is that this is a hard memory address. Each time the binary is run, the variables will always be located at these exact addresses. Now to get into the actual main method.</p>
                    </div>
                    <div class="col-sm-4">
                        <pre><code class="cpp">int a;
int b;
float c;</code></pre>
                        <pre><code class="x86asm">;a @ 0x8049634
;b @ 0x8049638
;c @ 0x804963c</code></pre></div>
                </div>
                <div class="row">
                    <div class="col-sm-8">
                        <p>
                            <br>The assignments in C are plain enough where <b>a = 10</b> and <b>b = 100</b>. It's a little different for x86. First, there are two syntaxs for x86 assembly (Intel and AT&amp;T). We'll be focusing on the Intel syntax. Now, onto the instructions.</p>
                        <p>In Intel syntax, the source is on the right and the destination is on the left. The <b>movl</b> instruction moves 32-bits from the source to the destination. The first instruction moves <b>0xa</b> (10 in decimal) to the memory location <b>0x8049634</b> which is actually the location of the <b>a</b> variable. Now that memory location has a value of 0xa which is what our C code did. The next line is very similar, I'll let you figure out what it does.</p>
                    </div>
                    <div class="col-sm-4">
                        <pre style="margin-top: 10%;"><code class="cpp">a = 10;
b = 100;</code></pre>
                        <pre><code class="x86asm">movl 0x8049634, 0xa
movl 0x8049638, 0x64</code></pre>
                    </div>
                </div>
                <div class="row">
                    <div class="col-sm-8">
                        <p>
                            <br>It's important to note that in x86, there are several general purpose registers that are used often: eax, ebx, ecx, and edx. For our purposes you can think of them as registers that are used to store values temporarily so that they can be used in operations such as addition or division.</p>
                        <p><b>mov</b> is much like <b>movl</b>, but it is mostly used with registers rather than immediate values. In this case, the value stored in <b>0x8049634</b> or <b>a</b> is moved into <b>edx</b>. The same is done with <b>b</b> and <b>eax</b>. The <b>lea</b> instruction is an optimization trick by the compiler that bypasses the ALU and uses the address bus. The ['s are actually dereferences an address. Essentially, it loads the value of <b>edx</b> + <b>eax</b> into <b>eax</b> meaning <b>eax</b> = <b>eax</b> + <b>edx</b>. The final line moves <b>eax</b> into the location that <b>a</b> is stored at.</p>
                    </div>
                    <div class="col-sm-4">
                        <pre style="margin-top: 10%;"><code class="cpp">a = a + b;</code></pre>
                        <pre><code class="x86asm">mov edx, 0x8049634
mov eax, 0x8049638
lea eax, [edx+eax*1]
mov 0x8049634, eax</code></pre></div>
                </div>
            </div>
        </div>
        <h3 class="text-center">Stack Example</h3>
        <div class="row bottom-pad">
            <div class="col-sm-3 col-sm-offset-2">
                <div class="container-fluid">
                    <p>On the bottom left, there are x86 register names as well as the corresponding values in those registers. We've seen <b>eax</b> and <b>ebx</b> before, but what's <b>esp</b>? The <b>esp</b> is the <b>Stack Register</b>. It keeps track of where exactly we are on the stack in memory.</p>
                    <p>The stack is divided into sections of 4 bytes also known as a word. This means that each time the stack value changes it's by a multiple of 4. Take note, that the stack starts at high memory addresses and grows to low memory address. Our starting value here is at 0x10000 as shown in the bottom left. When we push what is in <b>eax</b> onto the stack, the value of the stack point is decremented by 4 because it is growing towards lower memory. Then when we pop <b>ebx</b>, it means that the value at the stack pointer is moved into the specified register (<b>ebx</b> in this case). Then, the memory that the location was taking up is deallocated by moving the pointer back a word.</p>
                </div>
            </div>
            <div class="col-sm-4 well mobile-margin-left mobile-margin-right">
                <div class="row">
                    <div class="col-sm-5 col-sm-offset-3 bottom-pad">
                        <h5 class="text-center">0xFFFFFFFF</h5>
                        <div class="stack-loc" id="main-ex-stack">... &nbsp; &nbsp; ... Garbage</div>
                        <h5 class="text-center">0x00000000</h5>
                    </div>
                    <div class="col-sm-3" style="margin-top: 35px;">
                        <div class="row">
                            <pre><code class="x86asm" id="stack-example-asm">push eax
pop ebx</code></pre>
                            <button type="button" class="btn btn-success btn-lg center-block" style="margin-bottom: 10px;" id="stack-test-button">Start</button>
                        </div>
                    </div>
                </div>
                <div class="row">
                    <div class="col-sm-5" id="register-ex-stack">
                        <div class="stack-loc" style="float: left; display: inline; width: 50%;">eax ebx esp</div>
                        <div class="stack-loc" style="float: left; display: inline; width: 50%;">0xa &nbsp; 0x10000</div>
                    </div>
                </div>
            </div>
        </div>
        <div class="row bottom-pad" id="assembly">
            <h3 class="text-center">Local Variables</h3>
            <div class="col-sm-3 col-sm-offset-2">
                <pre><code class="cpp">  
    int main() {

        int a;
        int b;
        float c;
        a = 10;
        b = 100;
        c = 10.45;
        a = a + b;
        return 0;
    }
                </code></pre>
            </div>
            <div class="col-sm-3">
                <pre><code class="x86asm hljs">    ;a @ [ebp-0xc]
    ;b @ [ebp-0x8]
    ;c @ [ebp-0xa]
    main:
        mov ebp, esp
        sub esp, 0x10
        movl [ebp-0xc], 0xa
        movl [ebp-0x8], 0x64
        mov eax, 0x41273333
        mov [ebp-0x4], eax
        mov eax, [ebp-0x8]
        add [ebp-0xc], eax
        </code></pre>
            </div>
            <div class="col-sm-1 well stack-loc mobile-margin-left mobile-margin-right">0x41273333 0x64 0xa ???? ???? ????</div>
            <div class="col-sm-1 text-center">
                <p style="font-size: 5.4em;">&rarr;</p>
            </div>
            <div class="col-sm-1 well stack-loc mobile-margin-left mobile-margin-right">0x41273333 0x64 0x6e ???? ???? ????</div>
        </div>
        <div class="row" id="assembly">
            <div class="col-sm-6 col-sm-offset-3">
                <div class="row">
                    <div class="col-sm-8">
                        <p>So, what's the difference between global variables and local variables. The answer is scope, but you probably already knew that. Now, look back at the global variable example and you'll see that the variables have hard coded addresses in assembly. Now look at where the variables are stored when they're initialized as local variables. If you compare the global and local variable example, you'll see that the only real difference is that instead of the hex address, we have this weird <b>[ebp-NUM]</b> where <b>NUM</b> is any hex value.</p>
                        <p>To understand this, we'll need to know what the <b>ebp</b> is. The <b>ebp</b> is the <b>Base Pointer</b>, also known as the <b>Frame Pointer</b>. Whenever a function is called, depending on its memory needs, it may allocate some amount of the stack to use as scrap memory. This is where the <b>ebp</b> comes in. It acts as an indicator to the start of a function frame which is the start of the function's stack. When local variables are created they are stored on the stack because they are temporary and only live within their own scope. You can see their storage on stacks to the right of the example assembly code. Since the <b>ebp</b> has the location of the start of the stack for the function, the local variables can be accessed using offsets of it. Assuming the <b>ebp</b> points at the very top of the example stacks, <b>[ebp-0x4]</b> would be the first word shown on the stack with <b>[ebp-0x8]</b> being the second and so on.</p>
                    </div>
                    <div class="col-sm-4">
                        <pre><code class="cpp">int a;
int b;
float c;</code></pre>
                        <pre><code class="x86asm">;a @ [ebp-0xc]
;b @ [ebp-0x8]
;c @ [ebp-0x4]</code></pre>
                        <pre><code class="x86asm">mov ebp, esp
sub esp, 0x10</code></pre>
                    </div>
                </div>
                <div class="row">
                    <div class="col-sm-8">
                        <p>Just as with the global variable example, let's look at what the assignment of the local variables look like. The C code is the same for assignments, but the assembly code is different. Since the variables are local, they are located on the stack rather than at a hard coded address like the global variables. This means that accessing the variables on the stack will be done with an offset from <b>ebp</b>. The <b>movl</b> instruction has the same function as the global variable example. The rest of the assembly is essential the same as well, except with the reference to the variables replaced with offsets of <b>ebp</b> and since we can store stuff on the stack there is no need to use the <b>lea</b> instruction to add and store the results.</p>
                    </div>
                    <div class="col-sm-4">
                        <pre><code class="cpp">a = 10;
b = 100;</code></pre>
                        <pre><code class="x86asm">movl [ebp-0xc], 0xa
movl [ebp-0x8], 0x64</code></pre>
                    </div>
                </div>
            </div>
        </div>
        <h3 class="text-center">Local Variable Example</h3>
        <div class="row bottom-pad mobile-margin-left-small mobile-margin-right-small">
            <div class="col-sm-4 col-sm-offset-4 well">
                <div class="row">
                    <div class="col-sm-5 col-sm-offset-3 bottom-pad">
                        <h5 class="text-center">0xFFFFFFFF</h5>
                        <div class="stack-loc" id="local-var-ex-stack">..... &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</div>
                        <h5 class="text-center">0x00000000</h5>
                    </div>
                    <div class="col-sm-4" style="margin-top: 35px;">
                        <div class="row">
                            <pre><code class="x86asm" id="local-var-ex-asm">mov ebp, esp
sub esp, 0x10
movl [ebp-0xc], 0xa
movl [ebp-0x8], 0x64
mov eax, 0x41273333
mov [ebp-0x4], eax
mov eax, [ebp-0x8]
add [ebp-0xc], eax</code></pre>
                            <button type="button" class="btn btn-success btn-lg center-block" style="margin-bottom: 10px;" id="local-var-test-button">Start</button>
                        </div>
                    </div>
                </div>
                <div class="row">
                    <div class="col-sm-5" id="register-local-ex-stack">
                        <div class="stack-loc" style="float: left; display: inline; width: 50%;">eax esp ebp</div>
                        <div class="stack-loc" style="float: left; display: inline; width: 50%;">&nbsp; 0x10000 &nbsp;</div>
                    </div>
                </div>
                <div class="row" style="margin-top: 10px;">
                    <p class="text-center">Note: The blue highlight is the <b>ebp</b> and the yellow is <b>esp</b> on the stack.</p>
                </div>
            </div>
        </div>
        <div class="row" id="assembly">
            <h3 class="text-center">Function Frames and Calling Convention</h3>
            <div class="col-sm-3 col-sm-offset-3">
                <pre><code class="cpp">


int callee(int a, int b)
{
    return a + b + 1;
}



int main()
{
    int a;
    a = callee(10, 40);
    return a;
}




</code></pre>
            </div>
            <div class="col-sm-3">
                <pre><code class="x86asm hljs">callee:
    push ebp                ;0x8048394
    mov ebp, esp            ;0x8048395
    mov eax, [ebp+0xc]      ;0x8048397
    mov edx, [ebp+0x8]      ;0x804839a
    add eax, edx            ;0x804839d
    add eax, 0x1            ;0x80483a0
    pop ebp                 ;0x80483a3
    ret                     ;0x80483a4
main:
    push ebp                ;0x80483a5
    mov ebp, esp            ;0x80483a6
    sub esp, 0x18           ;0x80483a8
    movl [esp+0x4], 0x28    ;0x80483ab
    movl [esp+0x0], 0xa     ;0x80483b3
    call callee             ;0x80483ba
    mov [ebp-0x4], eax      ;0x80483bf
    mov eax, [ebp-0x4]      ;0x80483c2
    leave                   ;0x80483c5
    ret                     ;0x80483c6</code></pre>
            </div>
        </div>
    </div>
    <div class="row mobile-margin-left-small mobile-margin-right-small" id="assembly">
        <div class="col-sm-6 col-sm-offset-3">
            <div class="row">
                <div class="col-sm-8">
                    <p>We've already talked a little about what function frames are, so let's complete our understanding. To the right is what's known as the prologue of a function frame. The first thing that's always done is the <b>ebp</b> is pushed to the stack. This saves the previous function's <b>Frame Pointer</b> so that when it is returned to it knows where the start of it's stack is and it's local variables and memory can be accessed. The next operation that is essential is the <b>esp</b> is moved into the <b>ebp</b>. This essentially moves the <b>ebp</b> from the start of the stack to where the <b>esp</b> currently points to. This is to start a new function frame. The next step is only necessary for function frames that require space on the stack. The <b>sub</b> of some amount from <b>esp</b> allocates memory on the stack by creating space between <b>ebp</b> and <b>esp</b>.</p>
                </div>
                <div class="col-sm-4">
                    <pre><code class="x86asm">push ebp
mov ebp, esp
sub esp, 0x18</code></pre>
                </div>
            </div>
            <div class="row">
                <div class="col-sm-8">
                    <p>These two instructions are what's known as the epilogue of the function frame. The <b>leave</b> instruction is actually a combination of two instructions: <b>mov esp, ebp</b> and <b>pop ebp</b>. Moving <b>ebp</b> into <b>esp</b> essentially deletes the previously allocated stack. Now, the stack pointer is where the previous saved base pointer is. That is, where <b>ebp</b> was originally pushed in the The other instruction, <b>ret</b>, is actually an alias for <b>pop eip</b>. What's the <b>eip</b>? The <b>eip</b> is what's known as the instruction pointer. It's job is to move to the next instruction. The <b>eip</b> can't be directly effected by <b>pop</b>s which is why <b>ret</b> is used instead. If you look at the above example, the comments next to each line is the address of the instruction. The <b>eip</b> loads the next address of each instruction to ready it for execution.</p>
                </div>
                <div class="col-sm-4">
                    <pre><code class="x86asm">leave
ret</code></pre>
                </div>
            </div>
            <div class="row">
                <div class="col-sm-8">
                    <p>This leads us into the calling convection of x86 assembly called cdecl. The base of it is that all functions must have their parameters on the top of the stack before calling the function. If we look up we can see that the callee function takes two ints as parameters. You can see that before calle is called in assembly, the two instructions above it move integers to <b>esp+4</b> and <b>esp+0</b>. This is the same as pushing the ints one after the other since they would be on the same place on the stack. The reason they aren't pushed is because some of the stack was already allocated so it's better to use the allocated space. The <b>call</b> instruction, much like the leave instruction, is actually two instructions: <b>push eip</b> and <b>jmp FUNC</b>. There are two things to note. Firstly, the <b>push eip</b> actually pushed the address of the next instruction so that when we return to the original function we start executing at that instruction. Secondly, we haven't talked about the <b>jmp</b> instruction, but it's pretty simple. It just sets <b>eip</b> to the raw address or address of the label that it's given. The last thing to mention about cdecl is that the return data is always stored in <b>eax</b>.</p>
                </div>
                <div class="col-sm-4">
                    <pre><code class="x86asm">movl [esp+0x4], 0x28
movl [esp+0x0], 0xa
call callee</code></pre>
                </div>
            </div>
        </div>
    </div>
    <h3 class="text-center">Calling Convention Example</h3>
    <div class="row bottom-pad mobile-margin-left mobile-margin-right">
        <div class="col-sm-6 col-sm-offset-3 well">
            <div class="row">
                <div class="col-sm-4 col-sm-offset-3 bottom-pad">
                    <h5 class="text-center">0xFFFFFFFF</h5>
                    <div class="stack-loc" id="call-conv-ex-stack">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</div>
                    <h5 class="text-center">0x00000000</h5>
                </div>
                <div class="col-sm-5" style="margin-top: 35px;">
                    <div class="row">
                        <pre><code class="x86asm" id="call-conv-ex-asm">callee:
    push ebp                ;0x8048394
    mov ebp, esp            ;0x8048395
    mov eax, [ebp+0xc]      ;0x8048397
    mov edx, [ebp+0x8]      ;0x804839a
    add eax, edx            ;0x804839d
    add eax, 0x1            ;0x80483a0
    pop ebp                 ;0x80483a3
    ret                     ;0x80483a4
main:
    push ebp                ;0x80483a5
    mov ebp, esp            ;0x80483a6
    sub esp, 0x18           ;0x80483a8
    movl [esp+0x4], 0x28    ;0x80483ab
    movl [esp+0x0], 0xa     ;0x80483b3
    call callee             ;0x80483ba
    mov [ebp-0x4], eax      ;0x80483bf
    mov eax, [ebp-0x4]      ;0x80483c2
    leave                   ;0x80483c5
    ret                     ;0x80483c6</code></pre>
                        <button type="button" class="btn btn-success btn-lg center-block" style="margin-bottom: 10px;" id="call-conv-test-button">Start</button>
                    </div>
                </div>
            </div>
            <div class="row">
                <div class="col-sm-5" id="register-call-conv-ex-stack">
                    <div class="stack-loc" style="float: left; display: inline; width: 50%;">eax edx esp ebp eip</div>
                    <div class="stack-loc" style="float: left; display: inline; width: 50%;">&nbsp; &nbsp; 0x10004 0x100a0 0x80483a5</div>
                </div>
            </div>
            <div class="row" style="margin-top: 10px;">
                <p class="text-center">Note: The blue highlight is the <b>ebp</b> and the yellow is <b>esp</b> on the stack.</p>
            </div>
        </div>
    </div>
    </div>
    <div class="row bottom-pad bottom-pad mobile-margin-left mobile-margin-right" id="buffer-overflows">
        <h2 class="text-center"><b>Buffer Overflows</b></h1>
            <h3 class="text-center">The Accident</h2>
        <div class="row bottom-pad" id="assembly">
            <div class="col-sm-3 col-sm-offset-3">
                <pre><code class="language-cpp">   

#include "string.h"
#include "stdio.h"


void mycpy(char* str)
{
    char foo[4];
    strcyp(foo, str);
}


int main()
{
    mycpy("asu cse 340 fall 2015 rocks!");
    printf("After");
    return 0;
}



                </code></pre>
            </div>
            <div class="col-sm-3">
                <pre><code class="x86asm hljs">mycpy: 
    push ebp                    ;0x80483f4
    mov ebp, esp                ;0x80483f5
    sub esp, 0x28               ;0x80483f7
    mov eax, [ebp+0x8]          ;0x80483fa
    mov [esp+0x4], eax          ;0x80483fd
    lea eax, [ebp-0xc]          ;0x8048401
    mov [esp+0x0], eax          ;0x8048404
    call strcpy                 ;0x8048407
    leave                       ;0x804840c
    ret                         ;0x804840d
main:
    push ebp                    ;0x804840e
    mov ebp, esp                ;0x804840f
    sub esp, 0x10               ;0x8048414
    movl [esp+0x0], 0x8048504   ;0x8048417
    call mycpy                  ;0x804841e
    mov eax, 0x8048517          ;0x8048423
    mov [esp+0x0], eax          ;0x8048428
    call printf                 ;0x804842b
    mov eax, 0x0                ;0x8048430
    leave                       ;0x8048435
    ret                         ;0x8048436</code></pre>
            </div>
        </div>
        <div class="row bottom-pad">
            <div class="col-sm-6 col-sm-offset-3">
                <div class="row">
                    <div class="col-sm-8">
                        <p>We already know what the assembly does, so let's talk about what a buffer overflow is and why or how it can occur. Think back to how function frames work. If a function is called it pushes the address of the next instruction and then the prologue of the called function pushes the <b>ebp</b>. The other important factor is local variables. Remember that local variables are stored on the stack as offsets of the <b>ebp</b>. The combination of these two things is what can lead to a classic buffer overflow. Looking at C code, the basic example is allocating a local buffer with some amount of space and then over filling it. Find the flaw in the above code example and then try it below!</p>
                    </div>
                    <div class="col-sm-4">
                        <pre><code class="cpp">void mycpy(char* str)
{
    char foo[4];
    strcyp(foo, str);
}</code></pre></div>
                </div>
            </div>
        </div>
        <h3 class="text-center">Overflow Example</h3>
        <div class="row bottom-pad bottom-pad">
            <div class="col-sm-6 col-sm-offset-3 well">
                <div class="row">
                    <div class="col-sm-4 col-sm-offset-3 bottom-pad">
                        <h5 class="text-center">0xFFFFFFFF</h5>
                        <div class="stack-loc" id="overflow-ex-stack">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</div>
                        <h5 class="text-center">0x00000000</h5>
                    </div>
                    <div class="col-sm-5" style="margin-top: 35px;">
                        <div class="row">
                            <pre><code class="x86asm" id="overflow-ex-asm">mycpy: 
    push ebp                    ;0x80483f4
    mov ebp, esp                ;0x80483f5
    sub esp, 0x28               ;0x80483f7
    mov eax, [ebp+0x8]          ;0x80483fa
    mov [esp+0x4], eax          ;0x80483fd
    lea eax, [ebp-0xc]          ;0x8048401
    mov [esp+0x0], eax          ;0x8048404
    call strcpy                 ;0x8048407
    leave                       ;0x804840c
    ret                         ;0x804840d
main:
    push ebp                    ;0x804840e
    mov ebp, esp                ;0x804840f
    sub esp, 0x10               ;0x8048414
    movl [esp+0x0], 0x8048504   ;0x8048417
    call mycpy                  ;0x804841e
    mov eax, 0x8048517          ;0x8048423
    mov [esp+0x0], eax          ;0x8048428
    call printf                 ;0x804842b
    mov eax, 0x0                ;0x8048430
    leave                       ;0x8048435
    ret                         ;0x8048436</code></pre>
                            <button type="button" class="btn btn-success btn-lg center-block" style="margin-bottom: 10px;" id="overflow-test-button">Start</button>
                            <p class="text-center hidden" id="segfault-overflow" style="color: red;"><b>SEGFAULT: 0x22313032</b></p>
                        </div>
                    </div>
                </div>
                <div class="row">
                    <div class="col-sm-5" id="register-overflow-ex-stack">
                        <div class="stack-loc" style="float: left; display: inline; width: 50%;">eax esp ebp eip</div>
                        <div class="stack-loc" style="float: left; display: inline; width: 50%;">&nbsp; 0x10004 0x100a0 0x804840e</div>
                    </div>
                </div>
                <div class="row" style="margin-top: 10px;">
                    <p class="text-center">Note: The blue highlight is the <b>ebp</b> and the yellow is <b>esp</b> on the stack.</p>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="col-sm-6 col-sm-offset-3">
                <p>As the text at the end of the example states, there would be a segfault when the program returns. Why? It's actually pretty easy to understand. When the program calls <b>strcpy</b> it writes the string to the specified location on the stack which happens to be <b>ebp-0xc</b> which is also <b>0xffdc</b>. However, the string that's written to that location is much larger than four characters. This doesn't stop <b>strcpy</b> though. There's nothing that tells it not to write the entire string so it does. In the process, it overwrites what was previously on the stack. If you look at what is on the stack when strcpy is called you will see the <b>saved ebp</b> directly above where the <b>ebp</b> register points to. The <b>saved ebp</b> is the value of <b>ebp</b> from the previous function. Directly above that is what's called the <b>saved eip</b> which is the address of the instruction that we should return to when we finish this function.</p>
                <p>Now, when <b>strcpy</b> is called look at what happens to those values. They get completely overwritten by the contents of the string. Watch what happens when <b>leave</b> and <b>ret</b> are called. The value that is in <b>ebp</b> when leave is called is actually the little-endian value of the ascii in that location. The same is true of <b>eip</b> when <b>ret</b> is called. This means that the <b>eip</b> tries to go to the location of the instruction that is actually the little-endian ascii characters which is definitely not a valid address.</p>
                <p><b>P.S.</b> In x86, all values are actually little endian which means the most significant byte is actually the least significat byte. For example: the value of the string "step" is 0x73746570 to make this little-endian just reverse the byte order so it becomes 0x70657473.</p>
            </div>
        </div>
    </div>
    <h3 class="text-center">Calling Things You Shouldn't</h3>
    <div class="row">
        <div class="col-sm-4 col-sm-offset-3">
        </div>
        <div class="col-sm-3">
            <pre><code class="cpp" id="overflow-call-ex">
            </code></pre>
            </div>
        </div>
    <div class="row" id="shellcode">
        <h2 class="text-center"><b>Shellcode</b></h1>
            <h3 class="text-center">Coming Soon!</h2>
    </div>
    <div class="row" id="format-strings">
        <h2 class="text-center"><b>Format Strings</b></h1>
            <h3 class="text-center">Coming Soon!</h2>
    </div>
    <div class="row" id="rop">
        <h2 class="text-center"><b>ROP: Return Oriented Programming</b></h1>
            <h3 class="text-center">Coming Soon!</h2>
    </div>
    <div class="row" id="heap-exploit">
        <h2 class="text-center"><b>Heap Exploitation</b></h1>
            <h3 class="text-center">Coming Soon!</h2>
    </div>
    </div>
    <script src="../js/vendor/modernizr-3.5.0.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
    <script>
    window.jQuery || document.write('<script src="../js/vendor/jquery-3.2.1.min.js"><\/script>')
    </script>
    <script src="../js/plugins.js"></script>
    <script src="../js/main.js"></script>
    <script src="../highlight/highlight.pack.js"></script>
    <script>
    hljs.initHighlightingOnLoad();
    </script>
    <!-- Google Analytics: change UA-XXXXX-Y to be your site's ID. -->
    <!-- <script> -->
    <!--     window.ga=function(){ga.q.push(arguments)};ga.q=[];ga.l=+new Date; -->
    <!--     ga('create','UA-XXXXX-Y','auto');ga('send','pageview') -->
    <!-- </script> -->
    <!-- <script src="https://www.google-analytics.com/analytics.js" async defer></script> -->
</body>

</html>